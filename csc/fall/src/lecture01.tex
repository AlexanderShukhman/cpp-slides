\documentclass[aspectration=1610,t]{beamer}
\usepackage{csc}
\title{Лекция 1. Языки C и C++}


\date{
   \textbf{CS центр}\\
   5 сентября 2017\\
   Санкт-Петербург
}

\begin{document}
\begin{frame} 
  \titlepage
\end{frame}

\begin{frame}[fragile]{Язык \langc}
    \begin{itemize}
        \item Язык программирования \langcpp создан на основе языка \langc.

        \item 
            Язык программирования \langc разработан в начале 1973 года в 
            компании Bell Labs {\em Кеном Томпсоном} и {\em Деннисом Ритчи}.

        \item            
            Язык \langc был создан для использования в операционной системе UNIX.

        \item
            В связи с успехом UNIX язык \langc получил широкое
            распространение. 
            
        \item 
            На данный момент \langc является одним из самых распространённых языков
            программирования\\ (доступен на большинстве платформ).
                
        \item \langc~--- основной язык для низкоуровневой разработки.
    \end{itemize}
\end{frame}

\begin{frame}{Особенности \langc}
    \begin{itemize}
        \item {\bf Эффективность.}\\
            Язык С позволяет писать программы, которые напрямую работают с железом. 

        \item {\bf Стандартизированность.}\\
            Спецификация языка \langc является международным стандартом.
        
        \item {\bf Относительная простота.}\\
            Стандарт языка \langc занимает 230 страниц\\
            (против 700+ для \texttt{Java} и 1300+ для \langcpp).
    \end{itemize}
\end{frame}

\begin{frame}{Создание \langcpp}
    \begin{itemize}
        \item Разрабатывается с начала 1980-х годов.
            
        \item Создатель~--- сотрудник Bell Labs {\em Бьёрн Страуструп}.
            
        \item Изначально это было расширение языка \langc для поддержки работы с 
            классами и объектами.
            
        \item Это позволило проектировать программы на более высоком уровне
            абстракции.
            
        \item Ранние версии языка назывались ``\langc with classes''.

        \item Первый компилятор \texttt{cfront} перерабатывающий исходный код
            ``\langc с классами'' в исходный код на \langc. 
    \end{itemize}
\end{frame}

\begin{frame}{Развитие \langcpp}
    \begin{itemize}
        \item  К 1983 году в язык были добавленно много новых возможностей
            (виртуальные функции, перегрузка функций и операторов, ссылки, 
            константы, \dots)

        \item Получившийся язык перестал быть просто дополненной
            версией классического \langc и был переименован из ``\langc с классами'' в \langcpp. 
        
        \item Имя языка, получившееся в итоге, происходит от оператора 
            унарного постфиксного инкремента \langc{} '{\tt ++}' (увеличение значения переменной на единицу). 
            
        \item Язык также не был назван \texttt{D}, поскольку ``является расширением \langc
            и не пытается устранять проблемы путём удаления элементов \langc''.
        
        \item Язык начинает активно развиваться. Появляются новые компиляторы
             и среды разработки.
    \end{itemize}
\end{frame}

\begin{frame}{Стандартизация \langcpp}
    \begin{itemize}
        \item Лишь в 1998 году был ратифицирован международный стандарт языка 
            \langcpp: ISO/IEC 14882:1998 ``Standard for the \langcpp Programming
            Language''.
        
        \item В 2003 году был опубликован стандарт языка ISO/IEC 14882:2003, где были
            исправлены выявленные ошибки и недочёты предыдущей версии стандарта.

        \item В 2005 году был выпущен Library Technical Report 1 (TR1). 
            
        \item С 2005 года началась работа над новой версией стандарта, которая
            получила кодовое название C++0x. 
            
        \item В конце концов в 2011 году стандарт был принят и получил название
            \langcpp[11] ISO/IEC 14882:2011. 

        \item В 2014 году вышел \langcpp[14]: ISO/IEC 14882:2014. 
            
        \item В данный момент готовится к публикации \langcpp[17].
    \end{itemize}
\end{frame}

\begin{frame}{Совместимость \langc и \langcpp}

    \begin{itemize}
        \item Один из принципов разработки стандарта \langcpp~— это
            cохранение совместимости с \langc. 
            
        \item Синтаксис \langcpp унаследован от языка \langc. 
            
        \item \langcpp не является в строгом смысле надмножеством \langc.
            
        \item Можно писать программы на \langc так, чтобы они успешно
            компилировались на \langcpp.
            
        \item \langc и \langcpp сильно отличаются как по сложности, так и по принятым 
            архитектурным решениям, которые используются в обоих языках.
    \end{itemize}
\end{frame}

\begin{frame}{Характеристики языка \langcpp}
    Характеристики \langcpp:
    \begin{itemize}
        \item сложный,
        \item мультипарадигмальный,
        \item эффективный,
        \item низкоуровневый,
        \item компилируемый,
        \item статически типизированный.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Сложность}
    \begin{itemize}
        \item 
            Описание стандарта занимает более 1300 страниц текста.

        \item  Нет никакой возможности рассказать ``весь \langcpp'' в рамках
            одного, пусть даже очень большого курса.

        \item В \langcpp программисту позволено очень многое, и это влeчёт за
            собой большую ответственность.

        \item На плечи программиста ложится много дополнительной
            работы:
            \begin{itemize}
                \item проверка корректности данных, 
                \item управление памятью, 
                \item обработка низкоуровневых ошибок.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Мультипарадигмальный}
На \langcpp можно писать программы в рамках нескольких парадигм программирования:
    \begin{itemize}
        \item {\bf процедурное программирование}\\
            (код ``в стиле \langc''),
            
        \item {\bf объектно-ориентированное программирование}\\
            (классы, наследование, виртуальные функции, \dots).
            
        \item {\bf обобщённое программирование}\\
            (шаблоны функций и классов),

        \item {\bf функциональное программирование}\\
            (функторы, безымянные функции, замыкания),
            
        \item {\bf генеративное программирование}\\
            (метапрограммирование на шаблонах).
    \end{itemize}
\end{frame}

\begin{frame}{Эффективный}
Одна из фундаментальных идей языков \langc и \langcpp~--- {\em
отсутствие неявных накладных расходов}, которые присутствуют
в других более высокоуровневых языках программирования.


\begin{itemize}
\item   Программист сам выбирает уровень абстракции, на котором писать
каждую отдельную часть программы. 

\item   Можно реализовывать критические по производительности участки
программы максимально эффективно.

\item Эффективность делает \langcpp основным языком для разработки приложений
с компьютерной графикой (к примеру, игры).
\end{itemize}

\end{frame}

\begin{frame}{Низкоуровневый}
    Язык \langcpp, как и \langc, позволяет работать напрямую 
    с ресурсами компьютера.

    \begin{itemize}
        \item Позволяет писать низкоуровневые системные приложения 
            (например, драйверы операционной системы).
        
        \item
            Неаккуратное обращение с системными ресурсами 
            может привести к падению программы.
    \end{itemize}
    
    В \langcpp отсутствует автоматическое управление памятью. 
    \begin{itemize}
        \item Позволяет программисту получить полный контроль над программой.
            
        \item Необходимость заботиться об освобождении памяти.
    \end{itemize}
\end{frame}

\begin{frame}{Компилируемый}
\langcpp является компилируемым языком программирования.
\medskip

Для того, чтобы запустить программу на \langcpp, её нужно сначала
{\em скомпилировать}.
\medskip

Компиляция~--- преобразование текста программы на языке программирования
в машинный код.

\begin{itemize}
    \item Нет накладных расходов при исполнении программы.
    \item При компиляции можно отловить некоторые ошибки.
    \item Требуется компилировать для каждой платформы отдельно.
\end{itemize}

\end{frame}

\begin{frame}{Статическая типизация}
\langcpp является статически типизированным языком.
\medskip

\begin{enumerate}
    \item Каждая сущность в программе (переменная, функция и пр.) имеет свой
        тип,
    \item и этот тип определяется на момент компиляции. 
\end{enumerate}
Это нужно для того, чтобы
\begin{enumerate}
    \item вычислить размер памяти, который будет занимать каждая
переменная в программе,
    \item определить, какая функция будет вызываться в каждом конкретном месте. 
\end{enumerate}        

Всё это определяется на
момент компиляции и ``зашивается'' в скомпилированную программу. 

В машинном коде никаких типов уже нет~--- там идёт работа с последовательностями байт. 
\end{frame}


\begin{frame}[fragile]{Что такое компиляция?}
\begin{center}
    \begin{tikzpicture}[auto,thick,font=\tiny]
    \tikzstyle{arrow} = [>=stealth',shorten >=2pt, shorten <=2pt]
    \tikzstyle{file} = [rectangle,minimum width=7ex,minimum height=15mm,draw,thick]

    \node [shift={(0mm,0mm)}] (programmer) {\includegraphics[height=1cm]{programmer}};
    \node [file,shift={(35mm,0cm)}]  (file1) {\parbox{14mm}{Архитектура приложения}};
    \node [file,shift={(80mm,0cm)}]  (file2) {Код на \langcpp};
    \node [file,shift={(35mm,-3cm)}] (file3) {Машинный код};
    \node [shift={(80mm,-3cm)}] (computer) {\includegraphics[height=1cm]{computer}};
    \path [arrow,->] (programmer) edge node {Проектирование} (file1);
    \path [arrow,->] (file1) edge node {Программирование}  (file2);
    \path [arrow,->] (file3) edge node {Исполнение}        (computer);

    \draw[->, arrow] (file2.south) -- ++(0,-.6) -| (file3.north);
    \node [shift={(57mm,-12mm)}] {Компиляция};
    
    \node[cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud1) at (0cm, 1cm) {Идея};
    \node[cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud2) at (80mm, -2cm) {0101};
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]{Что такое компиляция?}
\begin{center}
\begin{tikzpicture}[auto,thick,font=\tiny]
    \tikzstyle{arrow} = [>=stealth',shorten >=2pt, shorten <=2pt]
    \tikzstyle{file} = [rectangle,minimum width=7ex,minimum height=15mm,draw,thick]

    \node [shift={(0mm,0mm)}] (programmer) {\includegraphics[height=1cm]{programmer}};
    \node [file,shift={(35mm,0cm)}]  (file1) {\parbox{14mm}{Архитектура приложения}};
    \node [file,shift={(80mm,0cm)}]  (file2) {Код на \texttt{Java}};
    \node [file,shift={(0mm,-3cm)}] (file3) {Байт код};
    \node [cloud, draw, shift={(35mm,-3cm)},label=below:JVM] (vm) {\includegraphics[height=8mm]{computer}};
    \node [shift={(80mm,-3cm)}] (computer) {\includegraphics[height=1cm]{computer}};
    \path [arrow,->] (programmer) edge node {Проектирование} (file1);
    \path [arrow,->] (file1) edge node {Программирование}  (file2);
    
    
    \draw [arrow,->] (file2.south) -- ++(0,-.6) -| (file3.north);
    \node [shift={(35mm,-12mm)}] {Компиляция};

    \path [arrow,->] (file3) edge node {Исполнение}        (vm);
    \path [arrow,<->] (vm) edge node {Трансляция команд}          (computer);
    
    \node[cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud1) at (0cm, 1cm) {Идея};
    \node[cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud2) at (80mm, -2cm) {0101};
\end{tikzpicture}
\end{center}
\end{frame}

\newcommand{\gear}[5]{%
\foreach \i in {1,...,#1} {%
  [rotate=(\i-1)*360/#1]  (0:#2)  arc (0:#4:#2) {%[rounded corners=1.5pt]
               -- (#4+#5:#3)  arc (#4+#5:360/#1-#5:#3)} --  (360/#1:#2)
               }} 

\begin{frame}[fragile]{Что такое интерпретация?}
\begin{center}
\begin{tikzpicture}[auto,thick,font=\tiny]
    \tikzstyle{arrow} = [auto, thick, >=stealth',shorten >=2pt, shorten <=2pt]
    \tikzstyle{file} = [rectangle,minimum width=1cm,minimum height=15mm,draw,thick]

    \node [shift={(0mm,0mm)}] (programmer) {\includegraphics[height=1cm]{programmer}};
    \node [file,shift={(35mm,0cm)}]  (file1) {\parbox{14mm}{Архитектура приложения}};
    \node [file,shift={(80mm,0cm)}]  (file2) {Код на \texttt{Perl}};
    \node [shift={(35mm,-3cm)},label=below:Интерпретатор,minimum
    height=15mm,minimum width=15mm] (perl) {Perl};
    
    \node [shift={(80mm,-3cm)}] (computer) {\includegraphics[height=1cm]{computer}};
    \path [arrow,->] (programmer) edge node {Проектирование} (file1);
    \path [arrow,->] (file1) edge node {Программирование}  (file2);
    \path [arrow,<->] (perl)   edge node {Трансляция команд} (computer);

    \draw [->, arrow] (file2.south) -- ++(0,-.6) -| (perl.north);
    \node [shift={(57mm,-12mm)}] {Интерпретация};
    
    \draw [thick,shift={(35mm,-3cm)}] \gear{10}{0.6}{.7}{10}{2};
    \draw [thick,shift={(35mm,-3cm)}] circle (.4); 
                                     
    \node [cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud1) at (0cm, 1cm) {Идея};
    \node [cloud, cloud puffs=15.7, cloud ignores aspect, align=center, draw]
        (cloud2) at (80mm, -2cm) {0101};
\end{tikzpicture}
\end{center}
\end{frame}

%С одной стороны находится человек, с другой -- компьютер. Компьютер и человек
%говорят на совершенно разных языках. Программирование -- это процесс перевода
%желаний человека на язык, понятный компьютеру.
%
%Это преобразование занимает несколько этапов.
%Предположим, что человек хочет написать графический редактор.
%Он понимает, как он работать с картинками.
%
%Для упрощения процесса будем считать, что человек -- это программист.
%Взаимодействие заказчика и программиста -- это отдельный сложный вопрос, который
%выходит за границы данного курса.
%
%Первый этап -- проектирование и алгоритмизация. На этом этапе программист
%описывает устройство программы в терминах сущностей, которые предоставляет
%конкретный язык программирования. К примеру, если мы говорит про ООП, то
%программист выделяет подсистемы, каждую из которых разбивает на классы, 
%выделяет интерфейсы классов и описывает объектную модель взаимодействия 
%между ними. Для каждой операции выбирается конкретный алгоритм, к примеру,
%для преобразования цветного изображения в черно-белое можно выбрать алгоритм,
%которые преобразует яркость пикселя в соответствующее значение ч/б пикселя 
%компоненту.
%
%Второй этап -- это реализация предложенного архитектурного и алгоритмического
%решения в терминах конкретного языка программирования. Т.е. в нашем примере, это
%непосредственное кодирование предложенной объектной модели приложения и
%выбранных алгоритмов на каком-то языке программирования. Результатом данного
%этапа является код программы выбранном на языке программирования.
%
%Третий этап -- это компиляция. В этот момент программа из языка, понятном
%программисту, транслируется на какой-то другой язык. Обычно в данном случае
%подразумевается язык понятный компьютеру -- в машинные коды.
%Иногда компиляция может происходить в несколько этапов. Так, к примеру, первый
%компилятор С++ cfront компилировал код на С++ в код на С, а потом уже вызывался
%компилятор С, который переводил код в машинные коды. Так и сейчас работают
%некоторые компиляторы С++ -- к примеру, компилятор Comeau. Язык С в данном
%случая, как я уже говорил, выступает в роли универсального ассемблера -- языка
%низкого уровня, который просто транслировать в машинные коды конкретной
%архитектуры. Существует множество языков, которые компилируются в С: Scheme,
%Haskell, OCaml и т.д.
%
%Очень часто язык программирования компилируется в язык ассемблера -- это такой
%специальный язык, который очень близок по структуре к машинным кодам конкретной
%архитектуры. Компилирование программы на языке ассемблера (ассемблирование) --
%это очень простой процесс, который можно представить как замену по словарю,
%когда каждой команде (к примеру, ``mov (%eax),%eax'' превратится в два байта
%``8b00'').
%
%Есть ещё и другие подходы. Антонимом к ``компилируемому языку'' является
%``интерпретируемый язык''. В этом случае этап 3 отсутствует, а вместо него
%используется специальная программа -- интерпретатор, которая читает код на языке
%программирования и выполняет все операции строчка за строчкой. По такой схеме
%работают различные скриптовые языки, к примеру, PHP и JavaScript.
%
%Ещё один вариант -- использование виртуальной машины. Для таких языков на этапе
%3 генерируется код не для конкретного процессора, а для некоторой абстрактного
%не существующего в природе процессора, который на каждой архитектуре реализован 
%в виде специальной программы -- виртуальной машины. Данный подход -- нечто 
%среднее между компилируемым языком и интерпретируемым, позволяющий сочетать 
%некоторые плюсы обоих решений. Так работают языки семейств Java и .Net.
%
%Давайте закончим данный фрагмент перечислением плюсов и минусов
%компилируемости языка.

\begin{frame}[fragile]{Плюсы и минусы компилируемости в машинный код}{}

    {\bf Плюсы:}
    \begin{itemize}
        \item эффективность: программа компилируется и оптимизируется для
            конкретного процессора,
        \item нет необходимости устанавливать сторонние приложения (такие как
            интерпретатор или виртуальная машина).
    \end{itemize}
    
    {\bf Минусы:}
    \begin{itemize}
        \item нужно компилировать для каждой платформы,
        \item сложность внесения изменения в программу~--- нужно перекомпилировать заново.
    \end{itemize}

{\bf Важно:} компиляция — преобразование одностороннее, нельзя восстановить исходный код.
\end{frame}


\begin{frame}[fragile]{Разбиение программы на файлы}

Зачем разбивать программу на файлы? 
\begin{itemize}
    \item С небольшими файлами удобнее работать.
    \item Разбиение на файлы структурирует код.
    \item Позволяет нескольким программистам разрабатывать 
        приложение одновременно.
    \item Ускорение повторной компиляции при небольших 
        изменениях в отдельных частях программы. 
        
\end{itemize}
    Файлы с кодом на \langcpp бывают двух типов:
    \begin{enumerate}
        \item файлы с исходным кодом (расширение \texttt{.cpp}, иногда \texttt{.C}),
        \item заголовочные файлы (расширение \texttt{.hpp} или \texttt{.h}).
    \end{enumerate}
\end{frame}

%Для того, чтобы говорить о компиляции С++ кода нужно сначала изучить
%его структуру. Программа на С++ состоит из двух типов файлов:
%файлов с исходным кодом (обычно с расширением .cpp или .С) и заголовочных файлов
%(с расширением .h или .hpp). Предполагается, что весь код написан в файлах с
%исходным кодом, а заголовочные файлы служат только для описания зависимостей.
%
%Давайте ответим на простой вопрос: зачем разбивать программу на
%файлы? Ответ просто: потому, что нам удобнее работать с небольшими файлами,
%чем с одним огромным, в котором ничего не найти. Это так же позволяет
%разрабатывать приложение по частям параллельно, когда каждый программист
%работает над какими-то своими файлами. Есть и другие причины для разделения на
%файлы -- это переиспользование кода (в случае библиотек) и ускорение перекомпиляции
%при небольших изменениях в отдельных частях программы. В таких случаях, если
%изменения затронули небольшое количество файлов, достаточно перекомпилировать
%только их.

\begin{frame}[fragile]{Заголовочные файлы}
\begin{itemize}
    \item Файл {\tt foo.cpp}:
{\small \begin{lstlisting}
// определение (definition) функции foo
void foo()
{
    bar();
}
\end{lstlisting}}

\item Файл {\tt bar.cpp}:
\begin{lstlisting}
// определение (definition) функции bar
void bar() { }
\end{lstlisting}

Компиляция этих файлов выдаст ошибку.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Заголовочные файлы}
\begin{itemize}
    \item Файл {\tt foo.cpp}:
{\small \begin{lstlisting}
// объявление (declaration) функции bar
void bar();

// определение (definition) функции foo
void foo()
{
    bar();
}
\end{lstlisting}}

\item Файл {\tt bar.cpp}:
\begin{lstlisting}
// определение (definition) функции bar
void bar() { }
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Заголовочные файлы}
    Предположим, что мы изменили функцию {\tt bar}.
\begin{itemize}
    \item Файл {\tt foo.cpp}:
{\small \begin{lstlisting}
void bar();

void foo()
{
    bar();
}
\end{lstlisting}}

\item Файл {\tt bar.cpp}:
\begin{lstlisting}
int bar() { return 1; }
\end{lstlisting}

Данный код некорректен — объявление отличается от определения.
(Неопределённое поведение.)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Заголовочные файлы}
    Добавим заголовочный файл {\tt bar.hpp}.
\begin{itemize}

    \item Файл {\tt foo.cpp}:
\begin{lstlisting}
#include "bar.hpp"

void foo()
{
    bar();
}
\end{lstlisting}

\item Файл {\tt bar.cpp}:
\begin{lstlisting}
int bar() { return 1; }
\end{lstlisting}

    \item Файл {\tt bar.hpp}:
\begin{lstlisting}
int bar();
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Двойное включение}
Может случиться двойное включение заголовочного файла.
\begin{itemize}
    \item Файл {\tt foo.cpp}:
\begin{lstlisting}
#include "foo.hpp"
#include "bar.hpp"

void foo()
{
    bar();
}
\end{lstlisting}

    \item Файл {\tt foo.hpp}:
\begin{lstlisting}
#include "bar.hpp"

void foo();
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Стражи включения}
Это можно исправить двумя способами:
\begin{itemize}
    \item (наиболее переносимо) Файл {\tt bar.hpp}:
\begin{lstlisting}
#ifndef BAR_HPP
#define BAR_HPP

int bar();
#endif
\end{lstlisting}
    \item (наиболее просто) Файл {\tt bar.hpp}: 
\begin{lstlisting}
#pragma once

int bar();
\end{lstlisting}
\end{itemize}
{\bf Резюме:} {\tt .cpp} — для определений, {\tt .hpp} — для объявлений.
\end{frame}



\begin{frame}[fragile]{Этап №1: препроцессор}
\begin{itemize}
    \item Язык препроцессора -- это специальный язык программирования, 
        встроенный в \langcpp.

    \item Препроцессор работает с кодом на \langcpp как с текстом.

    \item Команды языка препроцессор называют директивами,              
        все директивы начинаются со знака \code{\#}.

    \item Директива \code{\#include} позволяет подключать заголовочные файлы к файлам
        кода.
    \begin{enumerate}
        \item \code{\#include <foo.h>} --- библиотечный заголовочный файл,
        \item \code{\#include "bar.h"{}} --- локальный заголовочный файл.
    \end{enumerate}
    \item Препроцессор заменяет директиву \code{\#include "bar.h"{}} на содержимое
    файла \texttt{bar.h}.
\end{itemize}

%Тут важно отметить, что язык препроцессора ничего не знает о коде на С++. Т.е.
%потенциально можно использовать препроцессор С++ для других языков, т.к. после
%работы препроцессора всего его директивы из файлов удаляются. Это важно понимать
%потому, что иногда программисты стараются использовать конструкции препроцессора
%(макросы) для реализации некоторых конструкций языка (к примеру, функций). Это
%может привести к очень нехорошим последствиям. Мы это обсудим в дальнейшем.
%
%Чтобы посмотреть, что получилось после работы препроцессора нужно при компиляции
%указать ключ -E: 
%g++ -E program.cpp > program_preprocessed.cpp

\end{frame}

\begin{frame}[fragile]{Этап 2: компиляция}
\begin{itemize}
    \item На вход компилятору поступает код на \langcpp после обработки
        препроцессором.
        
    \item Каждый файл с кодом компилируется отдельно и независимо от других
        файлов с кодом.
        
    \item Компилируется только файлы с кодом (т.е. {\tt *.cpp}).
        
    \item Заголовочные файлы сами по себе ни во что не компилируются, только в
        составе файлов с кодом.
        
    \item На выходе компилятора из каждого файла с кодом получается ``объектный
        файл''~--- бинарный файл со скомпилированным кодом (с расширением
        \texttt{.o} или \texttt{.obj}).

    %Чтобы скомпилировать файл в объектный код нужно указать ключ -с 
    %(g++ -с program.cpp).
    %При желании можно попросить компилятор транслировать код в ассемблер
    %(g++ -S program.cpp).
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item На этом этапе все объектные файлы объединяются в один исполняемый 
        (или библиотечный) файл.

    \item При этом происходит подстановка адресов функций в места их вызова.
    \begin{lstlisting}
void foo()
{
    bar();
}
\end{lstlisting}

\begin{lstlisting}
void bar() {  }
\end{lstlisting}

    \item По каждому объектному файлу строится таблица всех
        функций, которые в нём определены.
\end{itemize}
%В данном примере в теле функции foo вызывается функция bar. Этой функции нет в
%файле foo.cpp. По этому при компиляции в место вызова функции bar будет
%вставлено указание "вызвать функцию bar". При линковке компоновщик
%просмотрит все объектные файлы и составит список всех объявленных функций. Потом
%он заменит каждое указание вида "вызвать функцию ..." на инструкцию вызова
%функции: посмотрит в таблице всех функций и если найдёт такую, то заменит эту
%инструкцию на вызов функции по адресу. Если такой инструкции не будет --
%произойдёт ошибка. Если вдруг окажется, что есть несколько одинаковых функций в
%разных объектных файлах, то это тоже приведёт к ошибке, т.к. линковщик не сможет
%определить какую из них использовать. 
\end{frame}

\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item На этапе компоновки важно, что каждая функция имеет уникальное имя.

    \item В \langcpp может быть две функции с одним именем, но разными
        параметрами.

    \item Имена функций искажаются (mangle) таким образом, что в их имени
        кодируются их параметры.\\
Например, компилятор GCC превратит имя функции \verb!foo!
\begin{lstlisting}
void foo(int, double) {}
\end{lstlisting}
в \verb!_Z3fooid!.

\item Аналогично функциям в линковке нуждаются глобальные переменные.

\end{itemize}
\end{frame}

\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item \emph{Точка входа} — функция, вызываемая при запуске программы.
        По умолчанию — это функция \verb!main!:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}
или
\begin{lstlisting}
int main(int argc, char ** argv)
{
    return 0;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Общая схема}
    \begin{center}
\begin{tikzpicture}[auto,thick,font=\tiny]
    \tikzstyle{arrow} = [>=stealth',shorten >=2pt, shorten <=2pt]
    \tikzstyle{file} = [rectangle,minimum width=7ex,minimum height=15mm,draw,thick]

    \node [file,shift={(0mm,0cm)}]    (file1) {{\tt file1.cpp}};
    \node [file,shift={(0mm,-2cm)}]   (file2) {{\tt file2.cpp}};
    \node [shift={(0mm,-35mm)}]        (filed) {$\vdots$};
    \node [file,shift={(0mm,-50mm)}]   (filen) {{\tt filen.cpp}};

    \node [file,shift={(4cm,0cm)}]    (file1o) {{\tt file1.o}};
    \node [file,shift={(4cm,-2cm)}]   (file2o) {{\tt file2.o}};
    \node [     shift={(4cm,-35mm)}]  (filedo) {$\vdots$};
    \node [file,shift={(4cm,-50mm)}]  (fileno) {{\tt filen.o}};

    \node [file,shift={(8cm,-25mm)}]    (program) {{\tt program}};

    \path [arrow,->] (file1) edge node {Компиляция}  (file1o);
    \path [arrow,->] (file2) edge node {}  (file2o);
    \path [arrow,->] (filen) edge node {}  (fileno);

    \path [arrow,->] (file1o) edge node {Линковка}  (program);
    \path [arrow,->] (file2o) edge node {}  (program);
    \path [arrow,->] (fileno) edge node {}  (program);
\end{tikzpicture}
    \end{center}
\end{frame}

\end{document}

