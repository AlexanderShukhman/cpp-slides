\documentclass[aspectration=1610]{beamer}

\usepackage{mooc}

\title{{\bf Программирование на языке \langcpp\protect\\Лекция
1\protect\vspace{1em}\\}Характеристики языка \langcpp}

\begin{document}
\begin{frame} 
  \titlepage
\end{frame}

\begin{frame}{Характеристики языка \langcpp}
    Характеристики \langcpp:
    \begin{itemize}
        \item сложный,
        \item мультипарадигмальный,
        \item эффективный,
        \item низкоуровневый,
        \item компилируемый,
        \item статически типизированный.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Сложность}
    \begin{itemize}
        \item 
            Описание стандарта занимает более 1300 страниц текста.

        \item  Нет никакой возможности рассказать ``весь \langcpp'' в рамках
            одного, пусть даже очень большого курса.

        \item В \langcpp программисту позволено очень многое, и это влeчёт за
            собой большую ответственность.

        \item На плечи программиста ложится много дополнительной
            работы:
            \begin{itemize}
                \item проверка корректности данных, 
                \item управление памятью, 
                \item обработка низкоуровневых ошибок.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Мультипарадигмальный}
На \langcpp можно писать программы в рамках нескольких парадигм программирования:
    \begin{itemize}
        \item {\bf процедурное программирование}\\
            (код ``в стиле \langc''),
            
        \item {\bf объектно-ориентированное программирование}\\
            (классы, наследование, виртуальные функции, \dots).
            
        \item {\bf обобщённое программирование}\\
            (шаблоны функций и классов),

        \item {\bf функциональное программирование}\\
            (функторы, безымянные функции, замыкания),
            
        \item {\bf генеративное программирование}\\
            (метапрограммирование на шаблонах).
    \end{itemize}
\end{frame}

\begin{frame}{Эффективный}
Одна из фундаментальных идей языков \langc и \langcpp~--- {\em
отсутствие неявных накладных расходов}, которые присутствуют
в других более высокоуровневых языках программирования.


\begin{itemize}
\item   Программист сам выбирает уровень абстракции, на котором писать
каждую отдельную часть программы. 

\item   Можно реализовывать критические по производительности участки
программы максимально эффективно.

\item Эффективность делает \langcpp основным языком для разработки приложений
с компьютерной графикой (к примеру, игры).
\end{itemize}

\end{frame}

\begin{frame}{Низкоуровневый}
    Язык \langcpp, как и \langc, позволяет работать напрямую 
    с ресурсами компьютера.

    \begin{itemize}
        \item Позволяет писать низкоуровневые системные приложения 
            (например, драйверы операционной системы).
        
        \item
            Неаккуратное обращение с системными ресурсами 
            может привести к падению программы.
    \end{itemize}
    
    В \langcpp отсутствует автоматическое управление памятью. 
    \begin{itemize}
        \item Позволяет программисту получить полный контроль над программой.
            
        \item Необходимость заботиться об освобождении памяти.
    \end{itemize}
\end{frame}

\begin{frame}{Компилируемый}
\langcpp является компилируемым языком программирования.
\medskip

Для того, чтобы запустить программу на \langcpp, её нужно сначала
{\em скомпилировать}.
\medskip

Компиляция~--- преобразование текста программы на языке программирования
в машинный код.

\begin{itemize}
    \item Нет накладных расходов при исполнении программы.
    \item При компиляции можно отловить некоторые ошибки.
    \item Требуется компилировать для каждой платформы отдельно.
\end{itemize}

\end{frame}

\begin{frame}{Статическая типизация}
\langcpp является статически типизированным языком.
\medskip

\begin{enumerate}
    \item Каждая сущность в программе (переменная, функция и пр.) имеет свой
        тип,
    \item и этот тип определяется на момент компиляции. 
\end{enumerate}
Это нужно для того, чтобы
\begin{enumerate}
    \item вычислить размер памяти, который будет занимать каждая
переменная в программе,
    \item определить, какая функция будет вызываться в каждом конкретном месте. 
\end{enumerate}        

Всё это определяется на
момент компиляции и ``зашивается'' в скомпилированную программу. 

В машинном коде никаких типов уже нет~--- там идёт работа с последовательностями байт. 
\end{frame}

\end{document}


