\documentclass{beamer}

\usepackage{mooc}

\usetikzlibrary{arrows, decorations.markings, shapes}
\usetikzlibrary{positioning}

% The face style, can be changed

\title{{\bf Программирование на языке \langcpp\protect\\Лекция
1\protect\vspace{1em}\\}Как компилируется программа на \langcpp?}

\begin{document}
\begin{frame} 
  \titlepage
\end{frame}



\begin{frame}[fragile]{Этап №1: препроцессор}
\begin{itemize}
    \item Язык препроцессора -- это специальный язык программирования, 
        встроенный в \langcpp.

    \item Препроцессор работает с кодом на \langcpp как с текстом.

    \item Команды языка препроцессора называют директивами,              
        все директивы начинаются со знака \code{\#}.

    \item Директива \code{\#include} позволяет подключать заголовочные файлы к файлам
        кода.
    \begin{enumerate}
        \item \code{\#include <foo.h>} --- библиотечный заголовочный файл,
        \item \code{\#include "bar.h"{}} --- локальный заголовочный файл.
    \end{enumerate}
    \item Препроцессор заменяет директиву \code{\#include "bar.h"{}} на содержимое
    файла \texttt{bar.h}.
\end{itemize}

%Тут важно отметить, что язык препроцессора ничего не знает о коде на С++. Т.е.
%потенциально можно использовать препроцессор С++ для других языков, т.к. после
%работы препроцессора всего его директивы из файлов удаляются. Это важно понимать
%потому, что иногда программисты стараются использовать конструкции препроцессора
%(макросы) для реализации некоторых конструкций языка (к примеру, функций). Это
%может привести к очень нехорошим последствиям. Мы это обсудим в дальнейшем.
%
%Чтобы посмотреть, что получилось после работы препроцессора нужно при компиляции
%указать ключ -E: 
%g++ -E program.cpp > program_preprocessed.cpp

\end{frame}

\begin{frame}[fragile]{Этап 2: компиляция}
\begin{itemize}
    \item На вход компилятору поступает код на \langcpp после обработки
        препроцессором.
        
    \item Каждый файл с кодом компилируется отдельно и независимо от других
        файлов с кодом.
        
    \item Компилируется только файлы с кодом (т.е. {\tt *.cpp}).
        
    \item Заголовочные файлы сами по себе ни во что не компилируются, только в
        составе файлов с кодом.
        
    \item На выходе компилятора из каждого файла с кодом получается ``объектный
        файл''~--- бинарный файл со скомпилированным кодом (с расширением
        \texttt{.o} или \texttt{.obj}).

    %Чтобы скомпилировать файл в объектный код нужно указать ключ -с 
    %(g++ -с program.cpp).
    %При желании можно попросить компилятор транслировать код в ассемблер
    %(g++ -S program.cpp).
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item На этом этапе все объектные файлы объединяются в один исполняемый 
        (или библиотечный) файл.

    \item При этом происходит подстановка адресов функций в места их вызова.
    \begin{lstlisting}
void foo()
{
    bar();
}
\end{lstlisting}

\begin{lstlisting}
void bar() {  }
\end{lstlisting}

    \item По каждому объектному файлу строится таблица всех
        функций, которые в нём определены.
\end{itemize}
%В данном примере в теле функции foo вызывается функция bar. Этой функции нет в
%файле foo.cpp. По этому при компиляции в место вызова функции bar будет
%вставлено указание "вызвать функцию bar". При линковке компоновщик
%просмотрит все объектные файлы и составит список всех объявленных функций. Потом
%он заменит каждое указание вида "вызвать функцию ..." на инструкцию вызова
%функции: посмотрит в таблице всех функций и если найдёт такую, то заменит эту
%инструкцию на вызов функции по адресу. Если такой инструкции не будет --
%произойдёт ошибка. Если вдруг окажется, что есть несколько одинаковых функций в
%разных объектных файлах, то это тоже приведёт к ошибке, т.к. линковщик не сможет
%определить какую из них использовать. 
\end{frame}

\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item На этапе компоновки важно, что каждая функция имеет уникальное имя.

    \item В \langcpp может быть две функции с одним именем, но разными
        параметрами.

    \item Имена функций искажаются (mangle) таким образом, что в их имени
        кодируются их параметры.\\
Например, компилятор GCC превратит имя функции \verb!foo!
\begin{lstlisting}
void foo(int, double) {}
\end{lstlisting}
в \verb!_Z3fooid!.

\item Аналогично функциям в линковке нуждаются глобальные переменные.

%На данном этапе важно, чтобы все функции имели разные имена. В С запрещено
%определять две различные функции с одинаковыми именами. В С++ это возможно, но в
%целях совместимости формат объектных файлов такой же как в С. Поэтому в С++ функции с
%одинаковыми именами, но разными параметрами (да и вообще все функции) на этапе компиляции
%преобразовываются (искажаются, от слова mangle) таким образом, что в их имени
%кодируются типы параметров, которые они принимают. Это позволяет использовать
%один и тот формат объектных файлов и один и тот же линковщик для C и С++.
%К примеру, имя функция void foo(int, double) {} превратится в "_Z3fooid".
%Для преобразования обратно поможет программа c++filt.
%
%Как мы увидим в дальнейшем линковка касается не только функций, но и глобальных
%переменных. Более того, бывают два уровня линковки: внешняя и внутренняя.
%
%Замечание: для сборки сложных больших проектов нужно использовать системы
%сборки.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Этап 3: линковка (компоновка)}
\begin{itemize}
    \item \emph{Точка входа} — функция, вызываемая при запуске программы.
        По умолчанию — это функция \verb!main!:
\begin{lstlisting}
int main()
{
    return 0;
}
\end{lstlisting}
или
\begin{lstlisting}
int main(int argc, char ** argv)
{
    return 0;
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Общая схема}
    \begin{center}
\begin{tikzpicture}[auto,thick,font=\tiny]
    \tikzstyle{arrow} = [>=stealth',shorten >=2pt, shorten <=2pt]
    \tikzstyle{file} = [rectangle,minimum width=7ex,minimum height=15mm,draw,thick]

    \node [file,shift={(0mm,0cm)}]    (file1) {{\tt file1.cpp}};
    \node [file,shift={(0mm,-2cm)}]   (file2) {{\tt file2.cpp}};
    \node [shift={(0mm,-35mm)}]        (filed) {$\vdots$};
    \node [file,shift={(0mm,-50mm)}]   (filen) {{\tt filen.cpp}};

    \node [file,shift={(4cm,0cm)}]    (file1o) {{\tt file1.o}};
    \node [file,shift={(4cm,-2cm)}]   (file2o) {{\tt file2.o}};
    \node [     shift={(4cm,-35mm)}]  (filedo) {$\vdots$};
    \node [file,shift={(4cm,-50mm)}]  (fileno) {{\tt filen.o}};

    \node [file,shift={(8cm,-25mm)}]    (program) {{\tt program}};

    \path [arrow,->] (file1) edge node {Компиляция}  (file1o);
    \path [arrow,->] (file2) edge node {}  (file2o);
    \path [arrow,->] (filen) edge node {}  (fileno);

    \path [arrow,->] (file1o) edge node {Линковка}  (program);
    \path [arrow,->] (file2o) edge node {}  (program);
    \path [arrow,->] (fileno) edge node {}  (program);
\end{tikzpicture}
    \end{center}
\end{frame}


\end{document}

